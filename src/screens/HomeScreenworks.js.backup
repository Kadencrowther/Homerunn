import React, { useState, useEffect, useCallback } from 'react';
import { 
  View, Text, StyleSheet, Image, TouchableOpacity, 
  Animated, Dimensions, Vibration, Platform, StatusBar, ScrollView 
} from 'react-native';
import Swiper from 'react-native-deck-swiper';
import { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';
import { FontAwesome } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import FilterModal from '../../src/components/FilterModal';
import { useSavedProperties } from '../../src/context/SavedPropertiesContext';
import { formatPrice } from '../../src/utils/formatters';
import SwipeTutorial from '../../src/components/SwipeTutorial';
import { auth, db } from '../../src/config/firebase';
import { doc, setDoc, getDoc, collection, getDocs } from 'firebase/firestore';
import { fetchMLSData } from '../../src/api/fetchMLSData';  // <-- Cloud Function fetch
import ShimmerEffect from '../../src/components/ShimmerEffect';
import ShimmerCards from '../components/ShimmerCards';
import LoadingCards from '../components/LoadingCards';

// Screen dimensions
const { width, height } = Dimensions.get('window');

// Layout constants for the Swiper cards
const HEADER_HEIGHT = Platform.OS === 'ios' ? 90 : (StatusBar.currentHeight + 60);
const TAB_BAR_HEIGHT = Platform.OS === 'ios' ? 83 : 60;
const CARD_MARGIN = 10;
const BOTTOM_PADDING = 25;
const CARD_HEIGHT = height - HEADER_HEIGHT - TAB_BAR_HEIGHT - (CARD_MARGIN * 2) - BOTTOM_PADDING;

const HomeScreen = () => {
  const navigation = useNavigation();

  // Add this function to determine badge color based on status
  const getStatusColor = (status) => {
    if (status === 'Active') return '#fc565b';
    if (status === 'Pending') return '#FFA500';
    if (status === 'Sold' || status === 'Closed') return '#4CAF50';
    return '#888888'; // Default gray for other statuses
  };

  // 1) Manage MLS data
  const [allListings, setAllListings] = useState([]);    // Entire set from Cloud Function
  const [currentDeck, setCurrentDeck] = useState([]);      // Currently displayed deck (filtered)
  const [isLoading, setIsLoading] = useState(true);

  // 2) Other states & logic
  const [overlayOpacity] = useState(new Animated.Value(0));
  const [showHeartOverlay, setShowHeartOverlay] = useState(false);
  const heartScale = useState(new Animated.Value(0))[0];
  const [particles] = useState([...Array(8)].map(() => new Animated.ValueXY({ x: 0, y: 0 })));
  const [overlayIcon, setOverlayIcon] = useState(null);
  const [swipedCards, setSwipedCards] = useState([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const { addToSaved, removeFromSaved } = useSavedProperties();

  const [isFilterModalVisible, setIsFilterModalVisible] = useState(false);
  const [filters, setFilters] = useState({
    screen: 'home',
    priceRange: { min: 0, max: 2000000 },
    beds: [],
    baths: [],
    sqft: { min: 0, max: 10000 },
    yearBuilt: { min: 1900, max: 2024 }
  });

  // Only one declaration for showTutorial and hasInteracted
  const [showTutorial, setShowTutorial] = useState(false);
  const [hasInteracted, setHasInteracted] = useState(false);

  // First, add a state to track if filters have been applied
  const [filtersApplied, setFiltersApplied] = useState(false);

  // 4) Define all functions BEFORE any conditional returns
  // Use useCallback to prevent unnecessary re-renders
  const animateHeart = useCallback(() => {
    // Show the heart overlay
    setShowHeartOverlay(true);
    setOverlayIcon('♥');
    
    // Animate overlay opacity
    Animated.timing(overlayOpacity, {
      toValue: 1,
      duration: 100,
      useNativeDriver: true
    }).start();
    
    // Animate heart scaling
    heartScale.setValue(0.1);
    Animated.sequence([
      Animated.spring(heartScale, {
        toValue: 1.2,
        friction: 4,
        tension: 40,
        useNativeDriver: true
      }),
      Animated.timing(heartScale, {
        toValue: 0,
        duration: 300,
        delay: 300,
        useNativeDriver: true
      })
    ]).start();
    
    // Hide the overlay after animation
    setTimeout(() => {
      Animated.timing(overlayOpacity, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true
      }).start(() => {
        setShowHeartOverlay(false);
        setOverlayIcon(null);
      });
    }, 800); // Use 800ms as the delay
  }, [heartScale, overlayOpacity]);

  const handleInteraction = useCallback(() => {
    if (!hasInteracted) setHasInteracted(true);
    if (showTutorial) setShowTutorial(false);
  }, [hasInteracted, showTutorial]);

  const handleSwipe = useCallback((cardIndex, direction) => {
    handleInteraction();
    const swipedCard = currentDeck[cardIndex];
    if (!swipedCard) return;

    if (direction === 'top') {
      Vibration.vibrate(20);
      animateHeart(); // Use the simplified animation
    }

    setSwipedCards(prev => [
      { ...swipedCard, action: direction, swipeIndex: currentIndex },
      ...prev
    ]);
    setCurrentIndex(prev => prev + 1);

    if (direction === 'left') {
      removeFromSaved(swipedCard.id);
    } else if (direction === 'right' || direction === 'top') {
      addToSaved({ ...swipedCard, loved: direction === 'top' });
    }
  }, [animateHeart, currentDeck, currentIndex, handleInteraction, addToSaved, removeFromSaved]);

  const handleRedo = useCallback(() => {
    handleInteraction();
    setHasInteracted(true);
    setShowTutorial(false);
    if (swipedCards.length === 0) return;
    const cardToRedo = swipedCards[0];
    setCurrentDeck(prev => [cardToRedo, ...prev]);
    setSwipedCards(prev => prev.slice(1));
    setCurrentIndex(prev => prev - 1);
  }, [handleInteraction, swipedCards]);

  const applyFilters = useCallback((newFilters) => {
    console.log('Applying filters to HomeScreen:', newFilters);
    const updatedFilters = { ...newFilters, hasBeenSet: true };
    setFilters(updatedFilters);
    setFiltersApplied(true);
    
    // Load data with the new filters - use updatedFilters directly
    async function applyNewFilters() {
      setIsLoading(true);
      try {
        // Use updatedFilters directly instead of filters state which hasn't updated yet
        const rawData = await fetchMLSData(updatedFilters);
        console.log(`Fetched ${rawData.length} properties with new filters`);
        
        // Verify each property meets the filter criteria
        const filteredData = rawData.filter(item => {
          // Check price range
          if (updatedFilters.priceRange) {
            if (updatedFilters.priceRange.max && item.ListPrice > parseInt(updatedFilters.priceRange.max)) {
              console.warn(`Filtering out property that exceeds max price: ${item.ListPrice} > ${updatedFilters.priceRange.max}`, 
                item.StreetNumber, item.StreetName);
              return false;
            }
            if (updatedFilters.priceRange.min && item.ListPrice < parseInt(updatedFilters.priceRange.min)) {
              return false;
            }
          }
          
          // Check beds
          if (updatedFilters.beds && updatedFilters.beds.length > 0) {
            const bedMatch = updatedFilters.beds.some(bed => {
              if (bed === '5+') return item.BedroomsTotal >= 5;
              return item.BedroomsTotal === parseInt(bed);
            });
            if (!bedMatch) return false;
          }
          
          // Check baths
          if (updatedFilters.baths && updatedFilters.baths.length > 0) {
            const bathMatch = updatedFilters.baths.some(bath => {
              if (bath === '5+') return item.BathroomsTotalInteger >= 5;
              return item.BathroomsTotalInteger === parseInt(bath);
            });
            if (!bathMatch) return false;
          }
          
          return true;
        });
        
        console.log(`After client-side filtering: ${filteredData.length} properties remain`);
        
        // Map the data (same mapping logic as above)
        const mapped = filteredData.map((item, idx) => {
          // Process images array
          let images = [];
          
          if (item.Media && Array.isArray(item.Media)) {
            // Filter for photos and map to proper image objects
            images = item.Media
              .filter(m => m.MediaCategory === 'Photo' && m.MediaURL)
              .map(m => ({ uri: m.MediaURL }));
          }
          
          // If no images were found, use a placeholder
          if (images.length === 0) {
            images.push(require('../../assets/house1.jpeg'));
          }
          
          return {
            id: item['@odata.id'] || `property-${idx}`,
            price: item.ListPrice || 0,
            beds: item.BedroomsTotal || 0,
            baths: item.BathroomsTotalInteger || 0,
            sqft: item.LivingArea || 0,
            address: `${item.StreetNumber || ''} ${item.StreetName || ''}, ${item.City || ''}, ${item.StateOrProvince || ''}`,
            images: images,
            yearBuilt: item.YearBuilt ? item.YearBuilt.toString() : 'N/A',
            lotSize: item.LotSizeSquareFeet || 0,
            propertyType: item.PropertyType || '',
            propertySubType: item.PropertySubType || '',
            daysOnMarket: item.DaysOnMarket || 0,
            listingStatus: item.StandardStatus || 'Active',
            description: item.PublicRemarks || '',
            mlsNumber: item.MLSNumber || '',
            listingOffice: item.ListingOffice || item.ListOfficeName || 'MLS Listing'
          };
        });
        
        setAllListings(mapped);
        setCurrentDeck(mapped);
      } catch (error) {
        console.error('Failed to apply new filters:', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    applyNewFilters();
    setCurrentIndex(0);
    setIsFilterModalVisible(false);
  }, []);

  const clearFilters = useCallback(() => {
    const defaultFilters = {
      screen: 'home',
      priceRange: { min: 0, max: 2000000 },
      beds: [],
      baths: [],
      sqft: { min: 0, max: 10000 },
      yearBuilt: { min: 1900, max: 2024 },
      hasBeenSet: false
    };
    setFilters(defaultFilters);
    setCurrentDeck(allListings);
    setCurrentIndex(0);
    setIsFilterModalVisible(false);
  }, [allListings]);

  // Fix the filter application in HomeScreen.js
  useEffect(() => {
    // Check if there's an active filter in Firebase when the component mounts
    async function checkForActiveFilter() {
      try {
        setIsLoading(true);
        const userId = auth.currentUser?.uid;
        
        if (userId) {
          // Get filters from the Users/{userId}/Filters collection
          const filtersRef = collection(db, 'Users', userId, 'Filters');
          const querySnapshot = await getDocs(filtersRef);
          
          let activeFilter = null;
          
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.IsActive) {
              activeFilter = {
                id: doc.id,
                priceRange: {
                  min: data.PriceRange?.Min || 0,
                  max: data.PriceRange?.Max || 2000000
                },
                beds: data.Beds || [],
                baths: data.Baths || [],
                sqft: {
                  min: data.Sqft?.Min || 0,
                  max: data.Sqft?.Max || 10000
                },
                yearBuilt: {
                  min: data.YearBuilt?.Min || 1900,
                  max: data.YearBuilt?.Max || new Date().getFullYear()
                },
                activeFilterId: doc.id
              };
            }
          });
          
          // If we found an active filter, apply it
          if (activeFilter) {
            console.log('Found active filter, applying:', activeFilter);
            setFilters(activeFilter);
            setFiltersApplied(true);
            await loadDataWithFilters(activeFilter);
          } else {
            // No active filter, load all data
            await loadDataWithFilters(null);
          }
        } else {
          // No user logged in, load all data
          await loadDataWithFilters(null);
        }
      } catch (error) {
        console.error('Error checking for active filter:', error);
        // Load all data if there's an error
        await loadDataWithFilters(null);
      } finally {
        setIsLoading(false);
      }
    }

    // Define the loadData function inside the useEffect
    async function loadDataWithFilters(filterOverride = null) {
      try {
        setIsLoading(true);
        // Use filterOverride if provided, otherwise use the state filters
        const filtersToUse = filterOverride || (filtersApplied ? filters : null);
        console.log('Loading data with filters:', filtersToUse);
        
        // Make sure we're passing the filters correctly to the API
        const rawData = await fetchMLSData(filtersToUse);
        console.log(`Fetched ${rawData.length} properties with filters:`, filtersToUse || 'No filters applied');
        
        // Log the first property to check its structure
        if (rawData.length > 0) {
          console.log('Sample property data:', {
            price: rawData[0].ListPrice,
            beds: rawData[0].BedroomsTotal,
            baths: rawData[0].BathroomsTotalInteger,
            yearBuilt: rawData[0].YearBuilt
          });
        }
        
        // Map the filtered data
        const mapped = rawData.map((item, idx) => {
          // Process images array
          let images = [];
          
          if (item.Media && Array.isArray(item.Media)) {
            // Filter for photos and map to proper image objects
            images = item.Media
              .filter(m => m.MediaCategory === 'Photo' && m.MediaURL)
              .map(m => ({ uri: m.MediaURL }));
          }
          
          // If no images were found, use a placeholder
          if (images.length === 0) {
            images.push(require('../../assets/house1.jpeg'));
          }
          
          return {
            id: item['@odata.id'] || `property-${idx}`,
            price: item.ListPrice || 0,
            beds: item.BedroomsTotal || 0,
            baths: item.BathroomsTotalInteger || 0,
            sqft: item.LivingArea || 0,
            address: `${item.StreetNumber || ''} ${item.StreetName || ''}, ${item.City || ''}, ${item.StateOrProvince || ''}`,
            images: images,
            yearBuilt: item.YearBuilt ? item.YearBuilt.toString() : 'N/A',
            lotSize: item.LotSizeSquareFeet || 0,
            propertyType: item.PropertyType || '',
            propertySubType: item.PropertySubType || '',
            daysOnMarket: item.DaysOnMarket || 0,
            listingStatus: item.StandardStatus || 'Active',
            description: item.PublicRemarks || '',
            mlsNumber: item.MLSNumber || '',
            listingOffice: item.ListingOffice || item.ListOfficeName || 'MLS Listing'
          };
        });
        
        console.log(`Mapped ${mapped.length} properties with details`);
        
        setAllListings(mapped);
        setCurrentDeck(mapped);
      } catch (error) {
        console.error('Failed to load MLS data:', error);
      } finally {
        setIsLoading(false);
      }
    }

    // Call the function to check for active filters and load data
    checkForActiveFilter();
    
    // No dependencies - this should only run once when the component mounts
  }, []);

  useEffect(() => {
    const unsubscribe = navigation.addListener('focus', () => {
      if (!filters.hasBeenSet) {
        const defaultFilters = {
          screen: 'home',
          priceRange: { min: 0, max: 2000000 },
          beds: [],
          baths: [],
          sqft: { min: 0, max: 10000 },
          yearBuilt: { min: 1900, max: 2024 },
          hasBeenSet: false
        };
        setFilters(defaultFilters);
        setCurrentDeck(allListings);
      }
    });
    return unsubscribe;
  }, [navigation, allListings, filters.hasBeenSet]);

  // Fix for the setTimeout in useEffect
  useEffect(() => {
    const handleAnimationStart = () => {
      setOverlayOpacity(new Animated.Value(1));
      setHeartScale(new Animated.Value(0.3));
      setParticles([...Array(12)].map(() => ({
        x: new Animated.Value(0),
        y: new Animated.Value(0),
        scale: new Animated.Value(0),
        alpha: new Animated.Value(0),
      })));
      
      Animated.parallel([
        Animated.timing(heartScale, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
        ...particles.map((particle, i) => {
          const angle = (i / particles.length) * 2 * Math.PI;
          const distance = 100 + Math.random() * 50;
          
          return Animated.parallel([
            Animated.timing(particle.x, {
              toValue: Math.cos(angle) * distance,
              duration: 800,
              useNativeDriver: true,
            }),
            Animated.timing(particle.y, {
              toValue: Math.sin(angle) * distance,
              duration: 800,
              useNativeDriver: true,
            }),
            Animated.timing(particle.scale, {
              toValue: Math.random() * 0.8 + 0.2,
              duration: 800,
              useNativeDriver: true,
            }),
            Animated.sequence([
              Animated.timing(particle.alpha, {
                toValue: Math.random() * 0.8 + 0.2,
                duration: 400,
                useNativeDriver: true,
              }),
              Animated.timing(particle.alpha, {
                toValue: 0,
                duration: 400,
                useNativeDriver: true,
              }),
            ]),
          ]);
        }),
      ]).start();
      
      setTimeout(() => {
        Animated.timing(overlayOpacity, {
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }).start(() => {
          setOverlayIcon(null);
        });
      }, 800);
    };
    
    if (overlayIcon) {
      handleAnimationStart();
    }
  }, [overlayOpacity, particles, heartScale]);

  // Conditional rendering for loading state
  if (isLoading) {
    return <LoadingCards />;
  }

  // 7) Render the component
  return (
    <TouchableOpacity activeOpacity={1} onPress={handleInteraction} style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View style={styles.logoContainer}>
          <Image source={require('../../assets/Homerunnhousecolorlogo.png')} style={styles.logo} />
          <Text style={styles.logoText}>HOMERUNN</Text>
        </View>
        <View style={styles.headerIcons}>
          <TouchableOpacity onPress={handleRedo} style={[styles.redoButton, { opacity: swipedCards.length > 0 ? 1 : 0.5 }]}>
            <Ionicons name="refresh" size={24} color={swipedCards.length > 0 ? "black" : "#ccc"} />
          </TouchableOpacity>
          <TouchableOpacity style={styles.bellButton} onPress={() => console.log('Bell icon pressed')}>
            <FontAwesome name="bell-o" size={20} color="black" />
          </TouchableOpacity>
          <TouchableOpacity onPress={() => setIsFilterModalVisible(true)} style={styles.filterButton}>
            <Ionicons name="filter" size={24} color="black" />
          </TouchableOpacity>
        </View>
      </View>

      {/* Swiper */}
      <View style={styles.swiperContainer}>
        <Swiper
          cards={currentDeck}
          renderCard={(card) => {
            if (!card) {
              return (
                <View style={[styles.card, { justifyContent: 'center', alignItems: 'center' }]}>
                  <Text style={{ fontSize: 18 }}>No properties</Text>
                </View>
              );
            }
            if (card.isPlaceholder) {
              return (
                <View style={[styles.card, { justifyContent: 'center', alignItems: 'center', backgroundColor: '#f8f9fa' }]}>
                  <Text style={{ fontSize: 18, textAlign: 'center', padding: 20, color: '#555' }}>
                    No properties match your filters.
                  </Text>
                  <TouchableOpacity style={{ marginTop: 20, padding: 12, backgroundColor: '#ff5a5f', borderRadius: 8 }} onPress={clearFilters}>
                    <Text style={{ color: 'white', fontWeight: 'bold' }}>Clear Filters</Text>
                  </TouchableOpacity>
                </View>
              );
            }
            return (
              <TouchableOpacity
                style={styles.card}
                onPress={() => {
                  navigation.navigate('PropertyImages', { property: card, sourceScreen: 'Home' });
                }}
                activeOpacity={1}
              >
                <View style={styles.imageContainer}>
                  {card.images && card.images.length > 0 ? (
                    <View style={styles.imageGrid}>
                      {/* First image (top third) */}
                      <Image 
                        source={typeof card.images[0] === 'number' ? card.images[0] : { uri: card.images[0].uri }} 
                        style={styles.stackedImage} 
                        resizeMode="cover" 
                      />
                      
                      {/* Second image (middle third) */}
                      {card.images.length > 1 ? (
                        <Image 
                          source={typeof card.images[1] === 'number' ? card.images[1] : { uri: card.images[1].uri }} 
                          style={styles.stackedImage} 
                          resizeMode="cover" 
                        />
                      ) : (
                        <Image 
                          source={require('../../assets/house1.jpeg')} 
                          style={styles.stackedImage} 
                          resizeMode="cover" 
                        />
                      )}
                      
                      {/* Third image (bottom third) */}
                      {card.images.length > 2 ? (
                        <Image 
                          source={typeof card.images[2] === 'number' ? card.images[2] : { uri: card.images[2].uri }} 
                          style={styles.stackedImage} 
                          resizeMode="cover" 
                        />
                      ) : (
                        <Image 
                          source={require('../../assets/house1.jpeg')} 
                          style={styles.stackedImage} 
                          resizeMode="cover" 
                        />
                      )}
                    </View>
                  ) : (
                    <View style={styles.imageGrid}>
                      <Image 
                        source={require('../../assets/house1.jpeg')} 
                        style={styles.stackedImage} 
                        resizeMode="cover" 
                      />
                      <Image 
                        source={require('../../assets/house1.jpeg')} 
                        style={styles.stackedImage} 
                        resizeMode="cover"
                      />
                      <Image 
                        source={require('../../assets/house1.jpeg')} 
                        style={styles.stackedImage} 
                        resizeMode="cover"
                      />
                    </View>
                  )}
                  
                  {/* Display listing status badge if available */}
                  {card.listingStatus && (
                    <View style={[styles.statusBadge, { backgroundColor: getStatusColor(card.listingStatus) }]}>
                      <Text style={styles.statusText}>{card.listingStatus}</Text>
                    </View>
                  )}
                </View>
                <View style={styles.cardDetails}>
                  <Text style={styles.price}>{formatPrice(card.price)}</Text>
                  <View style={styles.detailsContainer}>
                    <View style={styles.detailItem}>
                      <MaterialCommunityIcons name="bed-outline" size={16} color="#333" />
                      <Text style={styles.details}>{card.beds} bed</Text>
                    </View>
                    <View style={styles.detailItem}>
                      <MaterialCommunityIcons name="shower" size={16} color="#333" />
                      <Text style={styles.details}>{card.baths} bath</Text>
                    </View>
                    <View style={styles.detailItem}>
                      <MaterialCommunityIcons name="ruler-square" size={16} color="#333" />
                      <Text style={styles.details}>{card.sqft.toLocaleString()} sq ft</Text>
                    </View>
                  </View>
                  <Text style={styles.address}>{card.address}</Text>
                  {card.yearBuilt !== 'N/A' && (
                    <Text style={styles.yearBuilt}>Built in {card.yearBuilt}</Text>
                  )}
                </View>
              </TouchableOpacity>
            );
          }}
          stackSize={3}
          backgroundColor="transparent"
          cardVerticalMargin={0}
          cardHorizontalMargin={width * 0.04}
          marginBottom={BOTTOM_PADDING}
          marginTop={20}
          onSwipedLeft={(cardIndex) => handleSwipe(cardIndex, 'left')}
          onSwipedRight={(cardIndex) => handleSwipe(cardIndex, 'right')}
          onSwipedTop={(cardIndex) => handleSwipe(cardIndex, 'top')}
          disableBottomSwipe
          disableTopSwipe={false}
          cardIndex={0}
          stackAnimationFriction={10}
          stackAnimationTension={20}
          stackSeparation={14}
          outputRotationRange={["-10deg", "0deg", "10deg"]}
          overlayLabels={{
            left: {
              title: '×',
              style: {
                label: {
                  backgroundColor: 'transparent',
                  borderColor: 'transparent',
                  color: '#fff',
                  fontSize: height * 0.2,
                  borderWidth: 0,
                  position: 'absolute',
                  zIndex: 10
                },
                wrapper: {
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: CARD_HEIGHT,
                  borderRadius: 10,
                  overflow: 'hidden',
                  backgroundColor: 'rgba(0,0,0,0.3)',
                  zIndex: 5
                }
              }
            },
            right: {
              title: '✓',
              style: {
                label: {
                  backgroundColor: 'transparent',
                  borderColor: 'transparent',
                  color: '#fff',
                  fontSize: height * 0.2,
                  borderWidth: 0,
                  position: 'absolute',
                  zIndex: 10
                },
                wrapper: {
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: CARD_HEIGHT,
                  borderRadius: 10,
                  overflow: 'hidden',
                  backgroundColor: 'rgba(0,0,0,0.3)',
                  zIndex: 5
                }
              }
            },
            top: {
              title: '♥',
              style: {
                label: {
                  backgroundColor: 'transparent',
                  borderColor: 'transparent',
                  color: '#fff',
                  fontSize: height * 0.2,
                  borderWidth: 0,
                  position: 'absolute',
                  zIndex: 10
                },
                wrapper: {
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: CARD_HEIGHT,
                  borderRadius: 10,
                  overflow: 'hidden',
                  backgroundColor: 'rgba(0,0,0,0.3)',
                  zIndex: 5
                }
              }
            }
          }}
          overlayLabelStyle={{
            fontSize: height * 0.2,
            color: '#fff',
            fontWeight: 'bold'
          }}
          animateOverlayLabelsOpacity
          overlayOpacityHorizontalThreshold={width / 15}
          overlayOpacityVerticalThreshold={height / 15}
          inputOverlayLabelsOpacityRangeX={[-width / 5, -width / 10, 0, width / 10, width / 5]}
          inputOverlayLabelsOpacityRangeY={[-height / 5, -height / 10, 0, height / 10, height / 5]}
          outputOverlayLabelsOpacityRangeX={[0.8, 0.4, 0, 0.4, 0.8]}
          outputOverlayLabelsOpacityRangeY={[0.8, 0.4, 0, 0.4, 0.8]}
          overlayOpacityReverse={false}
          swipeAnimationDuration={350}
          animateCardOpacity={false}
          useViewOverflow
          containerStyle={{
            backgroundColor: 'transparent',
            paddingHorizontal: width * 0.02
          }}
          cardStyle={{
            position: 'absolute',
            top: 0,
            width: width * 0.92
          }}
        />
      </View>

      {/* Heart Overlay */}
      {showHeartOverlay && (
        <Animated.View style={[styles.overlay, { opacity: overlayOpacity }]}>
          <Animated.View style={{ transform: [{ scale: heartScale }] }}>
            <Text style={styles.heartSymbol}>{overlayIcon}</Text>
          </Animated.View>
        </Animated.View>
      )}

      {/* Filter Modal */}
      <FilterModal
        visible={isFilterModalVisible}
        onClose={() => setIsFilterModalVisible(false)}
        onApply={(newFilters) => {
          setFilters({ ...newFilters, screen: 'home' });
          applyFilters(newFilters);
          setIsFilterModalVisible(false);
        }}
        onClear={() => {
          const defaultFilters = {
            screen: 'home',
            priceRange: { min: 0, max: 2000000 },
            beds: [],
            baths: [],
            sqft: { min: 0, max: 10000 },
            yearBuilt: { min: 1900, max: 2024 }
          };
          setFilters(defaultFilters);
          setCurrentIndex(0);
          setCurrentDeck(allListings);
          setIsFilterModalVisible(false);
        }}
        currentFilters={filters}
        screen="home"
      />

      {/* Swipe Tutorial */}
      <SwipeTutorial
        visible={showTutorial}
        onDismiss={() => {
          setShowTutorial(false);
          setHasInteracted(true);
        }}
      />
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff'
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingTop: HEADER_HEIGHT - 30,
    paddingBottom: 16,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd'
  },
  logoContainer: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  logo: {
    width: 28,
    height: 28,
    marginRight: 8
  },
  logoText: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#fc565b'
  },
  headerIcons: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 8
  },
  bellButton: {
    marginHorizontal: 6
  },
  redoButton: {
    marginHorizontal: 6
  },
  filterButton: {
    marginHorizontal: 6
  },
  swiperContainer: {
    flex: 1,
    paddingTop: height * 0.01,
    paddingBottom: height * 0.01,
    backgroundColor: '#fff'
  },
  card: {
    backgroundColor: '#fff',
    borderRadius: 10,
    overflow: 'hidden',
    borderWidth: 1,
    borderColor: '#ddd',
    elevation: 3,
    height: CARD_HEIGHT,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.2,
    shadowRadius: 8
  },
  imageContainer: {
    height: '82%',
    flexDirection: 'column'
  },
  imageGrid: {
    flexDirection: 'column',
    height: '100%',
    width: '100%',
  },
  stackedImage: {
    width: '100%',
    height: '33.33%',
    resizeMode: 'cover',
  },
  cardDetails: {
    flex: 1,
    padding: 8,
    paddingHorizontal: 12,
    justifyContent: 'space-between',
    backgroundColor: 'rgba(245, 247, 250, 0.95)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -4 },
    shadowOpacity: 0.1,
    shadowRadius: 6
  },
  price: {
    fontSize: height * 0.035,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 1
  },
  detailsContainer: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center'
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 12
  },
  details: {
    fontSize: height * 0.024,
    color: '#333',
    fontWeight: '600',
    marginLeft: 4
  },
  address: {
    fontSize: height * 0.021,
    color: '#333'
  },
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0,0,0,0.3)',
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 1000
  },
  heartSymbol: {
    fontSize: height * 0.15,
    color: '#FFFFFF',
    fontWeight: 'bold'
  },
  statusBadge: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 100,
    height: 28,
    padding: 4,
    borderRadius: 4,
    justifyContent: 'center',
    alignItems: 'center'
  },
  statusText: {
    fontSize: height * 0.018,
    fontWeight: 'bold',
    color: '#fff',
    textAlign: 'center'
  },
  yearBuilt: {
    fontSize: height * 0.018,
    color: '#666',
    marginTop: 4
  },
  imageDots: {
    position: 'absolute',
    bottom: 10,
    left: 10,
    flexDirection: 'row',
    alignItems: 'center'
  },
  imageDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#fff',
    marginHorizontal: 2
  },
  skeletonCardsContainer: {
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
    height: CARD_HEIGHT,
    width: width * 0.92,
    marginTop: 30
  },
  skeletonCard: {
    position: 'absolute',
    width: width * 0.92,
    height: CARD_HEIGHT,
    backgroundColor: '#fff',
    borderRadius: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 1.5,
    elevation: 2,
    overflow: 'hidden'
  },
  skeletonCardBottom: {
    transform: [
      { scale: 0.9 },
      { translateY: 20 }
    ],
    zIndex: 1
  },
  skeletonCardMiddle: {
    transform: [
      { scale: 0.95 },
      { translateY: 10 }
    ],
    zIndex: 2
  },
  skeletonCardTop: {
    zIndex: 3
  },
  skeletonImageContainer: {
    height: CARD_HEIGHT * 0.6,
    backgroundColor: '#fff',
    borderTopLeftRadius: 10,
    borderTopRightRadius: 10,
    overflow: 'hidden',
    padding: 5
  },
  skeletonImageRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    height: '100%'
  },
  skeletonMainImage: {
    width: '60%',
    height: '100%',
    backgroundColor: '#f0f0f0',
    borderRadius: 5,
    marginRight: 5
  },
  skeletonSecondaryImagesContainer: {
    width: '38%',
    height: '100%',
    flexDirection: 'column',
    justifyContent: 'space-between'
  },
  skeletonSecondaryImage: {
    width: '100%',
    height: '48%',
    backgroundColor: '#f0f0f0',
    borderRadius: 5
  },
  skeletonDetails: {
    flex: 1,
    padding: 15
  },
  skeletonPrice: {
    height: 30,
    width: '50%',
    backgroundColor: '#f0f0f0',
    borderRadius: 4,
    marginBottom: 15
  },
  skeletonDetailsRow: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    alignItems: 'center',
    marginBottom: 15
  },
  skeletonDetailItem: {
    width: 70,
    height: 24,
    backgroundColor: '#f0f0f0',
    borderRadius: 4,
    marginRight: 15
  },
  skeletonAddress: {
    height: 18,
    width: '85%',
    backgroundColor: '#f0f0f0',
    borderRadius: 4,
    marginBottom: 8
  },
  skeletonYearBuilt: {
    height: 18,
    width: '40%',
    backgroundColor: '#f0f0f0',
    borderRadius: 4
  },
  skeletonStatusBadge: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 70,
    height: 24,
    backgroundColor: '#f0f0f0',
    padding: 4,
    borderRadius: 4
  }
});

export default HomeScreen;
